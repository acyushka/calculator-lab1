# Калькулятор M2

Калькулятор принимает на вход выражения в инфиксной форме, переводит их в RPN с помощью алгоритма сортировочной станции, затем подсчитывает выражение в RPN и выводит результат.


## Поддерживаемые операции:

Реализованы все операции, относящиеся к общем требованиям для М:

- `-x` `+x` - унарные знаки (да, они у меня токенизируются, как операции)

- `+` `-` `*` `/` - арифметические операции

- `//` `%` - целочисленные операции  

- `**` - степень (право-ассоциативная)

- `()` - скобочки


## Запуск программы

### Прописываем для запуска:

```Консоль

python -m src.main

```



### Примеры работы:

```Консоль

> Введите выражение: 2 + 3 * 4

Результат: 14

> Введите выражение: 5 / 0

Ошибка: Деление на ноль

```

### Для выхода прописываем `exit`



## Как правильно и неправильно писать выражения:

### Можно:

- `2.5`, `3` - разные форматы чисел

- `2+3`, `2 + 3`, `2     +         3` - пробелы не важны

- `-5`, `+3` - унарные операторы у чисел в начале строки

- `5 + (-2)` - унарные после бинарных операторов в скобках!!

- `2 ** 3 ** 2` - степени вычисляются справа налево

### Нельзя:

- `2 ++ 3` - два оператора подряд

- `* 3` - выражение начинается с бинарного оператора  

- `2 +` - выражение заканчивается оператором

- `5.5 // 2` - целочисленные операции только для целых чисел!!!!

- `()` - пустые скобки

- `2.`, `.3`, `.` - запрещенные форматы чисел



## Технические детали


### Допущения:
1. Калькулятор не считает вещественными (да и вообще числами) форматы чисел "x.", ".x", "."(ну к примеру 123. и .56), я считаю, что мне не стоит усложнять ради такого код и регулярку, я считаю, что пользователь в состоянии дописать нолик.
2. Не знаю куда про это писать, но пусть это будет допущением: чтобы получить результат каждой операции, я в файле operations.py импортирую либу operator и с помощью нее считаю, думаю это не будет считаться ошибкой, потому что она ничего не делает кроме операций собственно, но я прочитал в нескольких источниках, что этот способ быстрее вызова лямбда функций и прочего.


### Алгоритм работы:

Пользователь вводит выражение.

1. **Токенизация**
	Вызывается функция tokenize(выражение)
	Я вдохновился реализацией такой функции с онлайн лабы.
	Токен - кортеж из 2 элементов: тип токена(NUM, OP, EOF) - str и value токена(float если число и str если операция или знак окончания).
	Под капотом: мы сначала делаем проверку на пустой ввод, затем проходимся по строке, с помощью регулярки(записана в константах) отделяем части строки. Проверяем на каждой: если операция, тип выбираем OP и пишем значение, если число, сначала проверяем что предыдущий токен не число, в тип пишем NUM, в значение заносим float. Возвращаем список токенов.


2. **Валидация**
	По очереди вызываются 3 валидатора:
		1)Проверяет, что в выражении на концах не стоят знаки, которые не могут там стоять
		2)Проверяет, что нет двух подряд стоящих операторов, которым запрещено стоять рядом друг с другом
		3)Валидирует правильность расставления скобок с помощью стека, а потом еще проверяет что нет "()" - пустых скобок

3. **RPN-преобразование**
		Вызывается функция convert_to_rpn(список_токенов)
		Конвертируем список токенов в новый список токенов, но уже в порядке RPN.
		Алгоритм работы как у Дейкстры, примерно такой же, зацикливаться не будем.

4. **Вычисление**
	Затем вызывается функция calculate_rpn(список_токенов_rpn)
	Под капотом ловится деление на ноль, проверка, что // и % работают с целыми числами, а также обрабатываются ошибки у ** , переполнение, некорректные возведения в степень, деление на ноль, и образование комплексного числа.
		Если в процессе работы функции или окончания случается ситуация, которая явно показывает, что пользователь ввел какое-то неправильное выражение, ловится исключение. - Собственно если RPN считается неправильно, то я считаю, что оно покрывает все случаи неправильных вводов пользователя.



### Структура проекта:

```
calculator-lab1/
├── src/
│   ├── main.py           # Точка входа
|	├── tokenizer.py      # Токенизация
|	├── converter.py  # Преобразование в RPN
|	├── rpn_calculate.py # Вычисление RPN
|	├── validators.py     # Валидация выражений
|	├── operations.py     # Функции из operator для операторов
|	└── constants.py      # Константы и регулярка
├── tests/
│   ├── calculate_test.py  # Тест calculate_rpn()
|	├── converter_test.py # Тест convert_to_rpn()
|	├── full_test.py     # Тест вычислений полного цикла (всех 3 главных функций)
|	└── tokenize_test.py  # Тест tokenize()
├── .gitignore            # Игнорируемые файлы для Git
├── .pre-commit-config.yaml # Линтеры и тп
├── pyproject.toml        # Настройки проекта
├── requirements.txt      # Зависимости
└── README.md            # Документация
```


## Юнит тесты

Запуск всех тестов:

```консоль

pytest tests/ -v

```

Есть 4 файла для тестирования
3 из них с похожими названиями тестируют отдельные функции - tokenize(), convert_to_rpn(), calculate_rpn()
А последний файл делает полные тесты "от и до", то есть тестовое выражение проходит все 3 функции сразу.


## Примеры ошибочек

### Синтаксис:

- `2 + - 3` → "Два оператора не могут идти подряд!"

- `(2 + 3` → "Несбалансированные скобки"  

- `(   )` → "Пустые скобки в выражении"

- `2 +` → "Выражение не может заканчиваться оператором"

- `+ 2` → "Выражение не может начинаться с бинарного оператора"

- `2 @ 3` → "Некорректный ввод около: '@ 3'"

### Вычисления:

- `5 / 0` → "Деление на ноль"

- `5.5 // 2` → "Операция // поддерживает только целые числа"

- `(-1) ** 0.5` → "Некорректное возведение в степень"


Конец...
